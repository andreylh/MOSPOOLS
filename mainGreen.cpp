// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================
#include <stdlib.h>
#include <math.h>
#include <iostream>
//#include "./readParetoSets.hpp"
#include "OptFrame/Util/RandGenMersenneTwister.hpp"
#include "MOSPOOLS.hpp"

using namespace std;
using namespace optframe;


int main(int argc, char **argv)
{
	int nOfArguments = 5;

	if (argc != (1 + nOfArguments))
	{
		cout << "Parametros incorretos!" << endl;
		cout << "At least two parameters should be given : \n"
				"1 - instance \n"
				"3 - int - solver time limit \n"
				"2 - bool - Mip start (optional) - Default false \n"
				"4 - int - maxTriesForFirstFeasible (optional) - Default 1 \n"
				"5 - int NIntervals (optional) - Default 1 - other set values by hand at code \n" << endl;

		exit(1);
	}
	const char* instancia = argv[1];
	int tLim = atoi(argv[2]);
	bool mipStart = atoi(argv[3]);
	int argvMaxTries(atoi(argv[4]));
	int nIntervalsCoef = atoi(argv[5]);

	string filename = instancia;
	cout << "==============================================" << endl;
	cout << "filename = " << filename << endl;
	cout << "mipStart = " << mipStart << endl;
	cout << "tLim = " << tLim << endl;
	cout << "nIntervalsCoef(optinal) = " << nIntervalsCoef << endl;

	RandGenMersenneTwister rg;
	long seed = time(NULL);
	seed = 2;
	cout << "seed = " << seed << endl;
	srand(seed);
	rg.setSeed(seed);
	cout << "==============================================\n" << endl;

//	readParetoSets rPS;
//		rPS.exec(filename, mipStart, nIntervalsCoef, tLim);

	//	mModel.analyzeParetoFronts("./ResultadosFronteiras/ParetoFrontInputbWCMNExec27TLim10-bestMIPStart", 68, "./ResultadosFronteiras/ParetoFrontInputbWCMNExec27TLim10", 44);
	//	getchar();

	int nOptObj = 2;
	int nCriteria = 0;
	vector<double> referencePointsHV =
	{ 10000, 10000 };
	vector<double> utopicSol =
	{ -1000, 0};
	MOMETRICS<int> moMetrics(nOptObj);
//	SPOOLStruct spoolStruct(moMetrics, referencePointsHV, utopicSol);

	//Specific struct for Smart Storage Problems -- TODO -- Adapt for your problem your use default
	SPOOLStruct spoolStructSmartStorage(moMetrics, referencePointsHV, utopicSol);
	cplexMOPoolSearch mModel(rg, spoolStructSmartStorage);

	//================================
	//Generating objective functions weights with pre-defined vector of lambda values
	vector<vector<double> > vPossibleCoefs(nOptObj);
	/*vPossibleCoefs[0] =
	{	0, 0.5,1 };
	vPossibleCoefs[1] =
	{	0, 0.5,1 };*/
	vPossibleCoefs[0] =
		{	0, 0.2, 0.4, 0.6, 0.8 ,1 };
		vPossibleCoefs[1] =
		{	0, 0.2, 0.4, 0.6, 0.8 ,1 };

//	vPossibleCoefs[2] =
//	{	1, 10};
//	vPossibleCoefs[3] =
//	{	1};
//	vPossibleCoefs[4] =
//	{	0.01, 0.1};
//	vPossibleCoefs[5] =
//	{	1, 10};
//	vPossibleCoefs[6] =
//	{	1, 10};
//	vPossibleCoefs[0] =
//	{	1};
//	vPossibleCoefs[1] =
//	{	0.1};
//	vPossibleCoefs[2] =
//	{	1};
//	vPossibleCoefs[3] =
//	{	1};
//	vPossibleCoefs[4] =
//	{	0.01,};
//	vPossibleCoefs[5] =
//	{	1};
//	vPossibleCoefs[6] =
//	{	1};
	//================================

//	vector<double> referencePointsHV =
//	{ 100, 500, 30, 150, 1500, 30, 30 };
//	vector<double> utopicSol =
//	{ 0, 1, 1, 10, 0, 1, 2 };

//	readParetoSets rPS(nOptObj, moMetrics);
//	vector<string> vInstances =
//	{ "lowerLayerT6NExec64TLim10", "lowerLayerT6NExec64TLim20", "lowerLayerT6NExec64TLim30", "lowerLayerT6NExec64TLim40",
//			"lowerLayerT7NExec64TLim10", "lowerLayerT7NExec64TLim20", "lowerLayerT7NExec64TLim30", "lowerLayerT7NExec64TLim40",
//			"lowerLayerT10NExec64TLim20", "lowerLayerT10NExec64TLim30", "lowerLayerT10NExec64TLim40",
//			"lowerLayerT15NExec64TLim30", "lowerLayerT15NExec64TLim40" };
//	for (int i = 0; i < vInstances.size(); i++)
//	{
//		stringstream tempss;
//		tempss << "./ResultadosFronteirasGreen/" << vInstances[i];
//		vInstances[i] = tempss.str();
//	}
//	vInstances = generateInstanceNames();

//	rPS.exec(vInstances, utopicSol, referencePointsHV);
//	cout << "Read Pareto finished with sucess!" << endl;
//	getchar();

	vector<vector<double> > vMILPCoefs;
	mModel.fillVectorWithAllCombinations(vPossibleCoefs, vMILPCoefs);
	cout << "possible combination are:\n" << vMILPCoefs << endl;
	int maxTriesWithTLimUntilFirstFeasible = argvMaxTries; //max number of times it will optimize with tLim until finding the First Feasible
	maxTriesWithTLimUntilFirstFeasible = 30;

	vector<vector<double> > obtainedPFValues;
	obtainedPFValues = mModel.exec(filename, mipStart, vMILPCoefs, tLim, nOptObj, nCriteria, maxTriesWithTLimUntilFirstFeasible);


	cout<<obtainedPFValues<<endl;
//	 obj: + totalDist + timeToDeliver + nUsedDrones + dronesMaxSpeed
//	 + maximizeFinalCharge + makeSpanLC + makeSpanLD

//	double hv = moMetrics.hipervolumeWithExecRequested(obtainedPFValues, referencePointsHV, true);
//	double delta = moMetrics.deltaMetric(obtainedPFValues, utopicSol, true);
//	cout << "hv = " << hv << endl;
//	cout << "delta = " << delta << endl;

	cout << "Main finished com sucesso!" << endl;
}
